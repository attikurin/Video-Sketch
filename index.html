<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>動画＆カメラ お絵かきアプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- アイコン用 -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: white;
            overflow: hidden; /* スクロール防止 */
            touch-action: none; /* スマホでの誤動作防止 */
        }
        
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
        }

        /* ビデオ、画像、キャンバスを重ねるためのスタイル */
        .media-layer, #drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* アスペクト比を維持 */
        }

        #drawing-canvas {
            z-index: 20;
            cursor: crosshair;
        }

        /* コントロールパネルのスタイル */
        .glass-panel {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
        }

        /* カラーピッカーのカスタマイズ */
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
            border: 2px solid white;
        }

        /* 録画中の点滅アニメーション */
        .recording-pulse {
            animation: pulse-red 2s infinite;
        }
        @keyframes pulse-red {
            0% { background-color: #ef4444; box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { background-color: #b91c1c; box-shadow: 0 0 0 6px rgba(239, 68, 68, 0); }
            100% { background-color: #ef4444; box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col">

    <!-- 上部ツールバー：メディア操作 -->
    <header class="h-16 flex-none glass-panel m-2 p-2 flex items-center justify-between z-30">
        <div class="flex items-center gap-2">
            <h1 class="text-lg font-bold hidden md:block px-2">Video Sketch</h1>
            
            <!-- ファイル入力 (隠し要素) -->
            <input type="file" id="videoInput" accept="video/*" class="hidden">
            <input type="file" id="imageInput" accept="image/*" class="hidden">

            <button onclick="document.getElementById('videoInput').click()" class="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-3 py-1.5 rounded-lg text-sm transition">
                <i data-lucide="video"></i> <span class="hidden sm:inline">動画読込</span>
            </button>
            <button onclick="document.getElementById('imageInput').click()" class="flex items-center gap-2 bg-green-600 hover:bg-green-700 text-white px-3 py-1.5 rounded-lg text-sm transition">
                <i data-lucide="image"></i> <span class="hidden sm:inline">画像読込</span>
            </button>
            <button id="cameraBtn" class="flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white px-3 py-1.5 rounded-lg text-sm transition">
                <i data-lucide="camera"></i> <span class="hidden sm:inline">カメラ</span>
            </button>
        </div>

        <div class="flex items-center gap-2">
            <!-- 録画ボタンを追加 -->
            <button id="recordBtn" class="flex items-center gap-2 bg-gray-700 hover:bg-gray-600 text-white px-3 py-1.5 rounded-lg text-sm transition border border-gray-500">
                <div id="recordIcon" class="w-3 h-3 rounded-full bg-red-500"></div>
                <span id="recordText" class="hidden sm:inline">録画</span>
            </button>
            
            <button id="saveBtn" class="flex items-center gap-2 bg-purple-600 hover:bg-purple-700 text-white px-3 py-1.5 rounded-lg text-sm transition" title="現在の画面を画像保存">
                <i data-lucide="image-down"></i> <span class="hidden sm:inline">画像保存</span>
            </button>
            <button id="clearBtn" class="text-red-400 hover:text-red-300 px-3 py-1.5 border border-red-500/50 rounded-lg text-sm transition flex items-center gap-1">
                <i data-lucide="trash-2" class="w-4 h-4"></i> 全消去
            </button>
        </div>
    </header>

    <!-- メインエリア：表示・描画領域 -->
    <main class="flex-1 relative overflow-hidden bg-black m-2 mt-0 rounded-xl border border-gray-800">
        <div id="canvas-container">
            <!-- 動画要素 -->
            <video id="videoElement" class="media-layer hidden" playsinline loop muted></video>
            <!-- 画像要素 -->
            <img id="imageElement" class="media-layer hidden" alt="Uploaded Content">
            <!-- キャンバス -->
            <canvas id="drawing-canvas"></canvas>
            
            <!-- 初期メッセージ -->
            <div id="placeholder-msg" class="text-gray-500 text-center pointer-events-none">
                <i data-lucide="upload-cloud" class="w-16 h-16 mx-auto mb-2 opacity-50"></i>
                <p>動画または画像を読み込んでください<br>右上のボタンから選択</p>
            </div>
        </div>
    </main>

    <!-- 下部ツールバー：描画・再生コントロール -->
    <footer class="h-16 flex-none glass-panel m-2 mt-0 p-2 flex items-center justify-center gap-4 z-30">
        
        <!-- 再生コントロール (動画時のみ有効) -->
        <button id="playPauseBtn" class="w-10 h-10 rounded-full bg-white text-black flex items-center justify-center hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed">
            <i data-lucide="play" class="w-5 h-5 fill-current"></i>
        </button>

        <div class="h-8 w-px bg-gray-600 mx-2"></div>

        <!-- 描画ツール -->
        <div class="flex items-center gap-3">
            <label class="flex items-center gap-2 cursor-pointer">
                <input type="color" id="colorPicker" value="#ff0000">
            </label>
            
            <div class="flex items-center gap-2 bg-gray-800 rounded-lg px-3 py-1">
                <i data-lucide="pen-tool" class="w-4 h-4 text-gray-400"></i>
                <input type="range" id="lineWidth" min="1" max="20" value="3" class="w-24 accent-blue-500">
            </div>

            <button id="eraserBtn" class="p-2 rounded-lg hover:bg-gray-700 transition" title="消しゴムモード">
                <i data-lucide="eraser" class="w-5 h-5 text-gray-300"></i>
            </button>
        </div>
    </footer>

    <script>
        // アイコンの初期化
        lucide.createIcons();

        // 要素の取得
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const videoInput = document.getElementById('videoInput');
        const imageInput = document.getElementById('imageInput');
        const cameraBtn = document.getElementById('cameraBtn');
        const videoElement = document.getElementById('videoElement');
        const imageElement = document.getElementById('imageElement');
        const placeholderMsg = document.getElementById('placeholder-msg');
        const container = document.getElementById('canvas-container');
        
        const playPauseBtn = document.getElementById('playPauseBtn');
        const clearBtn = document.getElementById('clearBtn');
        const saveBtn = document.getElementById('saveBtn');
        const recordBtn = document.getElementById('recordBtn'); // 追加
        const recordText = document.getElementById('recordText'); // 追加
        const recordIcon = document.getElementById('recordIcon'); // 追加
        const colorPicker = document.getElementById('colorPicker');
        const lineWidthRange = document.getElementById('lineWidth');
        const eraserBtn = document.getElementById('eraserBtn');

        // 状態管理
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentMode = 'none'; // 'video', 'image', 'camera', 'none'
        let isEraser = false;
        let currentStream = null;

        // 録画用変数
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let recordingAnimationId;

        // キャンバスのサイズ調整
        function resizeCanvas() {
            // 親コンテナのサイズに合わせる
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // 初期実行

        // --- メディア処理 ---

        function resetMedia() {
            // 既存のメディアを停止・非表示
            videoElement.classList.add('hidden');
            imageElement.classList.add('hidden');
            videoElement.pause();
            videoElement.src = "";
            imageElement.src = "";
            placeholderMsg.classList.add('hidden');
            
            // カメラストリームの停止
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }

            // アイコン更新
            updatePlayButtonIcon(true);
        }

        // 動画読み込み
        videoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            resetMedia();
            const url = URL.createObjectURL(file);
            videoElement.src = url;
            videoElement.classList.remove('hidden');
            currentMode = 'video';
            
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                updatePlayButtonIcon(false);
            };
        });

        // 画像読み込み
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            resetMedia();
            const reader = new FileReader();
            reader.onload = (event) => {
                imageElement.src = event.target.result;
                imageElement.classList.remove('hidden');
                currentMode = 'image';
                playPauseBtn.disabled = true; // 画像時は再生ボタン無効
            };
            reader.readAsDataURL(file);
        });

        // カメラ起動
        cameraBtn.addEventListener('click', async () => {
            try {
                resetMedia();
                currentStream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement.srcObject = currentStream;
                videoElement.classList.remove('hidden');
                videoElement.play();
                currentMode = 'camera';
                playPauseBtn.disabled = true; // リアルタイムカメラは一時停止不可とする（フリーズ機能を作るなら別だが今回はシンプルに）
            } catch (err) {
                alert("カメラの起動に失敗しました: " + err.message);
            }
        });

        // --- 再生コントロール ---

        playPauseBtn.addEventListener('click', () => {
            if (currentMode === 'video' && videoElement.src) {
                if (videoElement.paused) {
                    videoElement.play();
                    updatePlayButtonIcon(false);
                } else {
                    videoElement.pause();
                    updatePlayButtonIcon(true);
                }
            }
        });

        function updatePlayButtonIcon(isPaused) {
            const icon = playPauseBtn.querySelector('svg');
            // Lucideアイコンの置換は少し複雑なので、innerHTMLで簡易対応
            if (isPaused) {
                playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play"><polygon points="6 3 20 12 6 21 6 3"/></svg>';
            } else {
                playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pause"><rect width="4" height="16" x="6" y="4"/><rect width="4" height="16" x="14" y="4"/></svg>';
            }
            
            if (currentMode === 'image' || currentMode === 'camera') {
                playPauseBtn.disabled = true;
                playPauseBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                playPauseBtn.disabled = false;
                playPauseBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }


        // --- 描画ロジック ---

        // 描画設定の取得
        function getDrawSettings() {
            return {
                // 修正: 消しゴム(destination-out)の場合、不透明な色で描画しないと消えません。
                // 以前の 'rgba(0,0,0,0)' を修正しました。
                color: isEraser ? '#000000' : colorPicker.value,
                width: lineWidthRange.value,
                composite: isEraser ? 'destination-out' : 'source-over'
            };
        }

        // 座標の取得 (マウス/タッチ共通化)
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.changedTouches) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function startDrawing(e) {
            isDrawing = true;
            const pos = getPos(e);
            lastX = pos.x;
            lastY = pos.y;
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault(); // スクロール防止

            const pos = getPos(e);
            const settings = getDrawSettings();

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(pos.x, pos.y);
            ctx.strokeStyle = settings.color;
            ctx.lineWidth = settings.width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = settings.composite;
            ctx.stroke();

            lastX = pos.x;
            lastY = pos.y;
        }

        function stopDrawing() {
            isDrawing = false;
            ctx.beginPath(); // パスをリセット
        }

        // イベントリスナー登録 (マウス)
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // イベントリスナー登録 (タッチ)
        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);

        // --- ツール機能 ---

        // 消しゴム切り替え
        eraserBtn.addEventListener('click', () => {
            isEraser = !isEraser;
            if (isEraser) {
                eraserBtn.classList.add('bg-blue-600', 'text-white');
                eraserBtn.classList.remove('hover:bg-gray-700');
            } else {
                eraserBtn.classList.remove('bg-blue-600', 'text-white');
                eraserBtn.classList.add('hover:bg-gray-700');
            }
        });
        
        // 色を選んだら消しゴムモード解除
        colorPicker.addEventListener('input', () => {
            if (isEraser) {
                isEraser = false;
                eraserBtn.classList.remove('bg-blue-600', 'text-white');
                eraserBtn.classList.add('hover:bg-gray-700');
            }
        });

        // 全消去
        clearBtn.addEventListener('click', () => {
            // 確認ダイアログなどは省略し、サクッと消す
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        // --- 保存機能 ---

        // object-fit: contain の描画位置計算
        function getContainRect(srcW, srcH, targetW, targetH) {
            const srcRatio = srcW / srcH;
            const targetRatio = targetW / targetH;
            let w, h, x, y;

            if (srcRatio > targetRatio) {
                // ソースの方が横長（上下に余白）
                w = targetW;
                h = targetW / srcRatio;
                x = 0;
                y = (targetH - h) / 2;
            } else {
                // ソースの方が縦長（左右に余白）
                h = targetH;
                w = targetH * srcRatio;
                y = 0;
                x = (targetW - w) / 2;
            }
            return { x, y, w, h };
        }

        // 共通の描画合成ロジック（画像保存と動画録画で使用）
        function drawCompositeFrame(targetCtx, targetWidth, targetHeight) {
            // 1. 背景色（黒）を塗る
            targetCtx.fillStyle = "#000000";
            targetCtx.fillRect(0, 0, targetWidth, targetHeight);

            // 2. メディア（動画/画像/カメラ）を描画
            let mediaSource = null;
            let srcW = 0, srcH = 0;

            if (currentMode === 'video' || currentMode === 'camera') {
                mediaSource = videoElement;
                srcW = videoElement.videoWidth;
                srcH = videoElement.videoHeight;
            } else if (currentMode === 'image') {
                mediaSource = imageElement;
                srcW = imageElement.naturalWidth;
                srcH = imageElement.naturalHeight;
            }

            if (mediaSource && srcW > 0 && srcH > 0) {
                const rect = getContainRect(srcW, srcH, targetWidth, targetHeight);
                targetCtx.drawImage(mediaSource, rect.x, rect.y, rect.w, rect.h);
            }

            // 3. お絵かきレイヤーを重ねる
            targetCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, targetWidth, targetHeight);
        }

        saveBtn.addEventListener('click', () => {
            // 合成用の一時キャンバスを作成
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            drawCompositeFrame(tempCtx, tempCanvas.width, tempCanvas.height);

            // ダウンロード処理
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            link.download = `snapshot_${timestamp}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        });

        // --- 動画録画機能 ---

        recordBtn.addEventListener('click', () => {
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        });

        function startRecording() {
            // 録画用キャンバスのセットアップ
            const recCanvas = document.createElement('canvas');
            recCanvas.width = canvas.width;
            recCanvas.height = canvas.height;
            const recCtx = recCanvas.getContext('2d');
            
            // リアルタイム合成ループ
            function renderLoop() {
                drawCompositeFrame(recCtx, recCanvas.width, recCanvas.height);
                recordingAnimationId = requestAnimationFrame(renderLoop);
            }
            renderLoop(); // ループ開始

            // ストリームの取得 (30fps)
            const stream = recCanvas.captureStream(30);

            // もし可能なら動画の音声も含める（簡易実装: 音声なし映像のみとして開始し、エラー回避）
            // ※背景動画の音声を混ぜるにはWeb Audio APIでの複雑なルーティングが必要なため、
            // 今回は「操作画面（映像）の録画」に特化します。

            // MediaRecorderの初期化
            const mimeTypes = [
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8',
                'video/webm',
                'video/mp4' // Safariなど一部環境用
            ];
            
            let options = {};
            for (const mimeType of mimeTypes) {
                if (MediaRecorder.isTypeSupported(mimeType)) {
                    options = { mimeType };
                    break;
                }
            }

            try {
                mediaRecorder = new MediaRecorder(stream, options);
            } catch (e) {
                alert('このブラウザは録画に対応していないか、エラーが発生しました。');
                cancelAnimationFrame(recordingAnimationId);
                return;
            }

            recordedChunks = [];
            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    recordedChunks.push(e.data);
                }
            };

            mediaRecorder.onstop = () => {
                cancelAnimationFrame(recordingAnimationId); // 合成ループ停止
                
                const blob = new Blob(recordedChunks, { type: options.mimeType || 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                // 拡張子の決定
                const ext = (options.mimeType && options.mimeType.includes('mp4')) ? 'mp4' : 'webm';
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                a.download = `recording_${timestamp}.${ext}`;
                document.body.appendChild(a);
                a.click();
                
                // クリーンアップ
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 100);
            };

            mediaRecorder.start();
            isRecording = true;

            // UI更新
            recordBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600', 'border-gray-500');
            recordBtn.classList.add('bg-red-600', 'hover:bg-red-700', 'border-red-500', 'recording-pulse');
            recordText.textContent = "停止";
            recordIcon.classList.add('bg-white');
            recordIcon.classList.remove('bg-red-500');
            
            // UI操作のロックなどはせず、録画中も自由に描画・操作可能
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            isRecording = false;

            // UI更新
            recordBtn.classList.add('bg-gray-700', 'hover:bg-gray-600', 'border-gray-500');
            recordBtn.classList.remove('bg-red-600', 'hover:bg-red-700', 'border-red-500', 'recording-pulse');
            recordText.textContent = "録画";
            recordIcon.classList.remove('bg-white');
            recordIcon.classList.add('bg-red-500');
        }

    </script>
</body>
</html>